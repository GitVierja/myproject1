{"ast":null,"code":"import { onStrategy, strategyHandling } from '@rx-angular/cdk/render-strategies';\nimport { of, BehaviorSubject, concat, EMPTY, merge, combineLatest, ReplaySubject } from 'rxjs';\nimport { ignoreElements, switchMap, map, withLatestFrom, catchError, tap, distinctUntilChanged } from 'rxjs/operators';\n\n/**\n * @internal\n * creates an embeddedViewRef\n *\n * @param viewContainerRef\n * @param templateRef\n * @param context\n * @param index\n * @return EmbeddedViewRef<C>\n */\nfunction createEmbeddedView(viewContainerRef, templateRef, context, index = 0) {\n  const view = viewContainerRef.createEmbeddedView(templateRef, context, index);\n  view.detectChanges();\n  return view;\n}\n/**\n * @internal\n *\n * A factory function returning an object to handle `TemplateRef`'s.\n * You can add and get a `TemplateRef`.\n *\n */\nfunction templateHandling(viewContainerRef) {\n  const templateCache = new Map();\n  const get$ = name => {\n    return templateCache.get(name) || of(undefined);\n  };\n  const get = name => {\n    let ref;\n    const templatRef$ = get$(name);\n    if (templatRef$) {\n      const sub = templatRef$.subscribe(r => ref = r);\n      sub.unsubscribe();\n    }\n    return ref;\n  };\n  return {\n    add(name, templateRef) {\n      assertTemplate(name, templateRef);\n      if (!templateCache.has(name)) {\n        templateCache.set(name, new BehaviorSubject(templateRef));\n      } else {\n        templateCache.get(name).next(templateRef);\n      }\n    },\n    get$,\n    get,\n    createEmbeddedView: (name, context) => createEmbeddedView(viewContainerRef, get(name), context)\n  };\n  //\n  function assertTemplate(property, templateRef) {\n    const isTemplateRefOrNull = !!(!templateRef || templateRef.createEmbeddedView);\n    if (!isTemplateRefOrNull) {\n      throw new Error(`${property} must be a TemplateRef, but received ${typeof templateRef}`);\n    }\n    return isTemplateRefOrNull;\n  }\n}\n/**\n * @internal\n *\n * A side effect operator similar to `tap` but with a static internal logic.\n * It calls detect changes on the 'VirtualParent' and the injectingViewCdRef.\n *\n * @param injectingViewCdRef\n * @param strategy\n * @param notifyNeeded\n * @param ngZone\n */\nfunction notifyAllParentsIfNeeded(injectingViewCdRef, strategy, notifyNeeded, ngZone) {\n  return o$ => o$.pipe(switchMap(v => {\n    const notifyParent = notifyNeeded();\n    if (!notifyParent) {\n      return of(v);\n    }\n    return concat(of(v), onStrategy(injectingViewCdRef, strategy, (_v, work, options) => {\n      /*console.log(\n       'notifyAllParentsIfNeeded injectingView',\n       (injectingViewCdRef as any).context\n       );*/\n      work(injectingViewCdRef, options.scope);\n    }, {\n      scope: injectingViewCdRef.context || injectingViewCdRef,\n      ngZone\n    }).pipe(ignoreElements()));\n  }));\n}\nvar RxBaseTemplateNames;\n(function (RxBaseTemplateNames) {\n  RxBaseTemplateNames[\"error\"] = \"errorTpl\";\n  RxBaseTemplateNames[\"complete\"] = \"completeTpl\";\n  RxBaseTemplateNames[\"suspense\"] = \"suspenseTpl\";\n})(RxBaseTemplateNames || (RxBaseTemplateNames = {}));\n\n/** @internal **/\nfunction isRxRenderError(e) {\n  return e != null && Array.isArray(e) && e.length === 2 && e[0] instanceof Error;\n}\n/** @internal **/\nfunction createErrorHandler(_handler) {\n  const _handleError = _handler ? e => _handler.handleError(e) : console.error;\n  return {\n    handleError: error => {\n      if (isRxRenderError(error)) {\n        _handleError(error[0]);\n        console.error('additionalErrorContext', error[1]);\n      } else {\n        _handleError(error);\n      }\n    }\n  };\n}\n/** @internal **/\nfunction toRenderError(e, context) {\n  return [e, context];\n}\n\n/**\n * @internal\n *\n * A factory function that returns a map of projections to turn a notification of a Observable (next, error, complete)\n *\n * @param customNextContext - projection function to provide custom properties as well as override existing\n */\nfunction notificationKindToViewContext(customNextContext) {\n  // @TODO rethink overrides\n  return {\n    suspense: notification => {\n      const $implicit = notification.value;\n      return {\n        $implicit,\n        suspense: true,\n        error: false,\n        complete: false,\n        ...customNextContext($implicit)\n      };\n    },\n    next: notification => {\n      const $implicit = notification.value;\n      return {\n        $implicit,\n        suspense: false,\n        error: false,\n        complete: false,\n        ...customNextContext($implicit)\n      };\n    },\n    error: notification => {\n      const $implicit = notification.value;\n      return {\n        $implicit,\n        complete: false,\n        error: notification.error || true,\n        suspense: false,\n        ...customNextContext($implicit)\n      };\n    },\n    complete: notification => {\n      const $implicit = notification.value;\n      return {\n        $implicit,\n        error: false,\n        complete: true,\n        suspense: false,\n        ...customNextContext($implicit)\n      };\n    }\n  };\n}\nfunction createTemplateManager(config) {\n  const {\n    renderSettings,\n    notificationToTemplateName,\n    templateSettings\n  } = config;\n  const {\n    defaultStrategyName,\n    strategies,\n    cdRef: injectingViewCdRef,\n    patchZone,\n    parent\n  } = renderSettings;\n  const errorHandler = createErrorHandler(renderSettings.errorHandler);\n  const ngZone = patchZone ? patchZone : undefined;\n  let activeTemplate;\n  const strategyHandling$ = strategyHandling(defaultStrategyName, strategies);\n  const templates = templateHandling(templateSettings.viewContainerRef);\n  const viewContainerRef = templateSettings.viewContainerRef;\n  const triggerHandling = config.templateTrigger$ || EMPTY;\n  const getContext = notificationKindToViewContext(templateSettings.customContext || (() => ({})));\n  return {\n    addTemplateRef: (name, templateRef) => {\n      templates.add(name, templateRef);\n    },\n    nextStrategy: strategyHandling$.next,\n    render(values$) {\n      let trg;\n      let notification = {\n        value: undefined,\n        complete: false,\n        error: false,\n        kind: \"suspense\" /* RxNotificationKind.Suspense */,\n        hasValue: false\n      };\n      return merge(values$.pipe(tap(n => notification = n)), triggerHandling.pipe(tap(trigger => trg = trigger))).pipe(switchMap(() => {\n        const contextKind = trg || notification.kind;\n        trg = undefined;\n        const value = notification.value;\n        const templateName = notificationToTemplateName[contextKind](value, templates);\n        return templates.get$(templateName).pipe(map(template => ({\n          template,\n          templateName,\n          notification,\n          contextKind\n        })));\n      }), withLatestFrom(strategyHandling$.strategy$),\n      // Cancel old renders\n      switchMap(([{\n        template,\n        templateName,\n        notification,\n        contextKind\n      }, strategy]) => {\n        const isNewTemplate = activeTemplate !== template || !template;\n        const notifyParent = isNewTemplate && parent;\n        return onStrategy(notification.value, strategy, (v, work, options) => {\n          const context = getContext[contextKind](notification);\n          if (isNewTemplate) {\n            // template has changed (undefined => next; suspense => next; ...)\n            // handle remove & insert\n            // remove current view if there is any\n            if (viewContainerRef.length > 0) {\n              // patch removal if needed\n              viewContainerRef.clear();\n            }\n            // create new view if any\n            if (template) {\n              // createEmbeddedView is already patched, no need for workFactory\n              templates.createEmbeddedView(templateName, context);\n            }\n          } else if (template) {\n            // template didn't change, update it\n            // handle update\n            const view = viewContainerRef.get(0);\n            Object.keys(context).forEach(k => {\n              view.context[k] = context[k];\n            });\n            // update view context, patch if needed\n            work(view, options.scope, notification);\n          }\n          activeTemplate = template;\n        }, {\n          ngZone\n        }\n        // we don't need to specify any scope here. The template manager is the only one\n        // who will call `viewRef#detectChanges` on any of the templates it manages.\n        // whenever a new value comes in, any pre-scheduled work of this taskManager will\n        // be nooped before a new work will be scheduled. This happens because of the implementation\n        // of `StrategyCredential#behavior`\n        ).pipe(notifyAllParentsIfNeeded(injectingViewCdRef, strategy, () => notifyParent, ngZone), catchError(e => {\n          errorHandler.handleError(e);\n          return of(e);\n        }));\n      }));\n    }\n  };\n}\n\n/**\n * @internal\n *\n * Factory that returns a `ListTemplateManager` for the passed params.\n *\n * @param templateSettings\n */\nfunction getTemplateHandler(templateSettings) {\n  const {\n    viewContainerRef,\n    initialTemplateRef,\n    createViewContext,\n    updateViewContext\n  } = templateSettings;\n  return {\n    updateUnchangedContext,\n    insertView,\n    moveView,\n    removeView,\n    getListChanges,\n    updateView\n  };\n  // =====\n  function updateUnchangedContext(item, index, count) {\n    const view = viewContainerRef.get(index);\n    updateViewContext(item, view, {\n      count,\n      index\n    });\n    view.detectChanges();\n  }\n  function moveView(oldIndex, item, index, count) {\n    const oldView = viewContainerRef.get(oldIndex);\n    const view = viewContainerRef.move(oldView, index);\n    updateViewContext(item, view, {\n      count,\n      index\n    });\n    view.detectChanges();\n  }\n  function updateView(item, index, count) {\n    const view = viewContainerRef.get(index);\n    updateViewContext(item, view, {\n      count,\n      index\n    });\n    view.detectChanges();\n  }\n  function removeView(index) {\n    return viewContainerRef.remove(index);\n  }\n  function insertView(item, index, count) {\n    createEmbeddedView(viewContainerRef, initialTemplateRef, createViewContext(item, {\n      count,\n      index\n    }), index);\n  }\n}\n/**\n * @internal\n *\n * @param changes\n * @param items\n */\nfunction getListChanges(changes, items) {\n  const changedIdxs = new Set();\n  const changesArr = [];\n  let notifyParent = false;\n  changes.forEachOperation((record, adjustedPreviousIndex, currentIndex) => {\n    const item = record.item;\n    if (record.previousIndex == null) {\n      // insert\n      changesArr.push(getInsertChange(item, currentIndex === null ? undefined : currentIndex));\n      changedIdxs.add(item);\n      notifyParent = true;\n    } else if (currentIndex == null) {\n      // remove\n      changesArr.push(getRemoveChange(item, adjustedPreviousIndex === null ? undefined : adjustedPreviousIndex));\n      notifyParent = true;\n    } else if (adjustedPreviousIndex !== null) {\n      // move\n      changesArr.push(getMoveChange(item, currentIndex, adjustedPreviousIndex));\n      changedIdxs.add(item);\n      notifyParent = true;\n    }\n  });\n  changes.forEachIdentityChange(record => {\n    const item = record.item;\n    if (!changedIdxs.has(item)) {\n      changesArr.push(getUpdateChange(item, record.currentIndex));\n      changedIdxs.add(item);\n    }\n  });\n  items.forEach((item, index) => {\n    if (!changedIdxs.has(item)) {\n      changesArr.push(getUnchangedChange(item, index));\n    }\n  });\n  return [changesArr, notifyParent];\n  // ==========\n  function getMoveChange(item, currentIndex, adjustedPreviousIndex) {\n    return [2 /* RxListTemplateChangeType.move */, [item, currentIndex, adjustedPreviousIndex]];\n  }\n  function getUpdateChange(item, currentIndex) {\n    return [3 /* RxListTemplateChangeType.update */, [item, currentIndex]];\n  }\n  function getUnchangedChange(item, index) {\n    return [4 /* RxListTemplateChangeType.context */, [item, index]];\n  }\n  function getInsertChange(item, currentIndex) {\n    return [0 /* RxListTemplateChangeType.insert */, [item, currentIndex === null ? undefined : currentIndex]];\n  }\n  function getRemoveChange(item, adjustedPreviousIndex) {\n    return [1 /* RxListTemplateChangeType.remove */, [item, adjustedPreviousIndex === null ? undefined : adjustedPreviousIndex]];\n  }\n}\nfunction createListTemplateManager(config) {\n  const {\n    templateSettings,\n    renderSettings,\n    trackBy,\n    iterableDiffers\n  } = config;\n  const {\n    defaultStrategyName,\n    strategies,\n    cdRef: injectingViewCdRef,\n    patchZone,\n    parent\n  } = renderSettings;\n  const errorHandler = createErrorHandler(renderSettings.errorHandler);\n  const ngZone = patchZone ? patchZone : undefined;\n  const strategyHandling$ = strategyHandling(defaultStrategyName, strategies);\n  let _differ;\n  function getDiffer(values) {\n    if (_differ) {\n      return _differ;\n    }\n    return values ? _differ = iterableDiffers.find(values).create(trackBy) : null;\n  }\n  //               type,  context\n  /* TODO (regarding createView): this is currently not in use. for the list-manager this would mean to provide\n   functions for not only create. developers than should have to provide create, move, remove,... the whole thing.\n   i don't know if this is the right decision for a first RC */\n  const listViewHandler = getTemplateHandler({\n    ...templateSettings,\n    initialTemplateRef: templateSettings.templateRef\n  });\n  const viewContainerRef = templateSettings.viewContainerRef;\n  let notifyParent = false;\n  let changesArr;\n  let partiallyFinished = false;\n  return {\n    nextStrategy(nextConfig) {\n      strategyHandling$.next(nextConfig);\n    },\n    render(values$) {\n      return values$.pipe(render());\n    }\n  };\n  function handleError() {\n    return o$ => o$.pipe(catchError(err => {\n      partiallyFinished = false;\n      errorHandler.handleError(err);\n      return of(null);\n    }));\n  }\n  function render() {\n    return o$ => combineLatest([o$, strategyHandling$.strategy$.pipe(distinctUntilChanged())]).pipe(map(([iterable, strategy]) => {\n      const differ = getDiffer(iterable);\n      let changes;\n      if (differ) {\n        if (partiallyFinished) {\n          const currentIterable = [];\n          for (let i = 0, ilen = viewContainerRef.length; i < ilen; i++) {\n            const viewRef = viewContainerRef.get(i);\n            currentIterable[i] = viewRef.context.$implicit;\n          }\n          differ.diff(currentIterable);\n        }\n        changes = differ.diff(iterable);\n      }\n      return {\n        changes,\n        iterable,\n        strategy\n      };\n    }),\n    // Cancel old renders\n    switchMap(({\n      changes,\n      iterable,\n      strategy\n    }) => {\n      if (!changes) {\n        return of([]);\n      }\n      const values = iterable || [];\n      // TODO: we might want to treat other iterables in a more performant way than Array.from()\n      const items = Array.isArray(values) ? values : Array.from(iterable);\n      const listChanges = listViewHandler.getListChanges(changes, items);\n      changesArr = listChanges[0];\n      const insertedOrRemoved = listChanges[1];\n      const applyChanges$ = getObservablesFromChangesArray(changesArr, strategy, items.length);\n      partiallyFinished = true;\n      notifyParent = insertedOrRemoved && parent;\n      return combineLatest(applyChanges$.length > 0 ? applyChanges$ : [of(null)]).pipe(tap(() => partiallyFinished = false), notifyAllParentsIfNeeded(injectingViewCdRef, strategy, () => notifyParent, ngZone), handleError(), map(() => iterable));\n    }), handleError());\n  }\n  /**\n   * @internal\n   *\n   * returns an array of streams which process all of the view updates needed to reflect the latest diff to the\n   * viewContainer.\n   * I\n   *\n   * @param changes\n   * @param strategy\n   * @param count\n   */\n  function getObservablesFromChangesArray(changes, strategy, count) {\n    return changes.length > 0 ? changes.map(change => {\n      const payload = change[1];\n      return onStrategy(change[0], strategy, type => {\n        switch (type) {\n          case 0 /* RxListTemplateChangeType.insert */:\n            listViewHandler.insertView(payload[0], payload[1], count);\n            break;\n          case 2 /* RxListTemplateChangeType.move */:\n            listViewHandler.moveView(payload[2], payload[0], payload[1], count);\n            break;\n          case 1 /* RxListTemplateChangeType.remove */:\n            listViewHandler.removeView(payload[1]);\n            break;\n          case 3 /* RxListTemplateChangeType.update */:\n            listViewHandler.updateView(payload[0], payload[1], count);\n            break;\n          case 4 /* RxListTemplateChangeType.context */:\n            listViewHandler.updateUnchangedContext(payload[0], payload[1], count);\n            break;\n        }\n      }, {\n        ngZone\n      });\n    }) : [of(null)];\n  }\n}\nconst computeFirst = ({\n  count,\n  index\n}) => index === 0;\nconst computeLast = ({\n  count,\n  index\n}) => index === count - 1;\nconst computeEven = ({\n  count,\n  index\n}) => index % 2 === 0;\nclass RxDefaultListViewContext {\n  _item = new ReplaySubject(1);\n  item$ = this._item.asObservable();\n  _$implicit;\n  _$complete;\n  _$error;\n  _$suspense;\n  _context$ = new BehaviorSubject({\n    index: -1,\n    count: -1\n  });\n  set $implicit($implicit) {\n    this._$implicit = $implicit;\n    this._item.next($implicit);\n  }\n  get $implicit() {\n    return this._$implicit;\n  }\n  get $complete() {\n    return this._$complete;\n  }\n  get $error() {\n    return this._$error;\n  }\n  get $suspense() {\n    return this._$suspense;\n  }\n  get index() {\n    return this._context$.getValue().index;\n  }\n  get count() {\n    return this._context$.getValue().count;\n  }\n  get first() {\n    return computeFirst(this._context$.getValue());\n  }\n  get last() {\n    return computeLast(this._context$.getValue());\n  }\n  get even() {\n    return computeEven(this._context$.getValue());\n  }\n  get odd() {\n    return !this.even;\n  }\n  get index$() {\n    return this._context$.pipe(map(c => c.index), distinctUntilChanged());\n  }\n  get count$() {\n    return this._context$.pipe(map(s => s.count), distinctUntilChanged());\n  }\n  get first$() {\n    return this._context$.pipe(map(computeFirst), distinctUntilChanged());\n  }\n  get last$() {\n    return this._context$.pipe(map(computeLast), distinctUntilChanged());\n  }\n  get even$() {\n    return this._context$.pipe(map(computeEven), distinctUntilChanged());\n  }\n  get odd$() {\n    return this.even$.pipe(map(even => !even));\n  }\n  constructor(item, customProps) {\n    this.$implicit = item;\n    if (customProps) {\n      this.updateContext(customProps);\n    }\n  }\n  updateContext(newProps) {\n    this._context$.next({\n      ...this._context$.getValue(),\n      ...newProps\n    });\n  }\n  select = props => {\n    return this.item$.pipe(map(r => props.reduce((acc, key) => acc?.[key], r)));\n  };\n}\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { RxBaseTemplateNames, RxDefaultListViewContext, createListTemplateManager, createTemplateManager, templateHandling };","map":{"version":3,"names":["onStrategy","strategyHandling","of","BehaviorSubject","concat","EMPTY","merge","combineLatest","ReplaySubject","ignoreElements","switchMap","map","withLatestFrom","catchError","tap","distinctUntilChanged","createEmbeddedView","viewContainerRef","templateRef","context","index","view","detectChanges","templateHandling","templateCache","Map","get$","name","get","undefined","ref","templatRef$","sub","subscribe","r","unsubscribe","add","assertTemplate","has","set","next","property","isTemplateRefOrNull","Error","notifyAllParentsIfNeeded","injectingViewCdRef","strategy","notifyNeeded","ngZone","o$","pipe","v","notifyParent","_v","work","options","scope","RxBaseTemplateNames","isRxRenderError","e","Array","isArray","length","createErrorHandler","_handler","_handleError","handleError","console","error","toRenderError","notificationKindToViewContext","customNextContext","suspense","notification","$implicit","value","complete","createTemplateManager","config","renderSettings","notificationToTemplateName","templateSettings","defaultStrategyName","strategies","cdRef","patchZone","parent","errorHandler","activeTemplate","strategyHandling$","templates","triggerHandling","templateTrigger$","getContext","customContext","addTemplateRef","nextStrategy","render","values$","trg","kind","hasValue","n","trigger","contextKind","templateName","template","strategy$","isNewTemplate","clear","Object","keys","forEach","k","getTemplateHandler","initialTemplateRef","createViewContext","updateViewContext","updateUnchangedContext","insertView","moveView","removeView","getListChanges","updateView","item","count","oldIndex","oldView","move","remove","changes","items","changedIdxs","Set","changesArr","forEachOperation","record","adjustedPreviousIndex","currentIndex","previousIndex","push","getInsertChange","getRemoveChange","getMoveChange","forEachIdentityChange","getUpdateChange","getUnchangedChange","createListTemplateManager","trackBy","iterableDiffers","_differ","getDiffer","values","find","create","listViewHandler","partiallyFinished","nextConfig","err","iterable","differ","currentIterable","i","ilen","viewRef","diff","from","listChanges","insertedOrRemoved","applyChanges$","getObservablesFromChangesArray","change","payload","type","computeFirst","computeLast","computeEven","RxDefaultListViewContext","_item","item$","asObservable","_$implicit","_$complete","_$error","_$suspense","_context$","$complete","$error","$suspense","getValue","first","last","even","odd","index$","c","count$","s","first$","last$","even$","odd$","constructor","customProps","updateContext","newProps","select","props","reduce","acc","key"],"sources":["C:/Users/javie/KarateGit/myproject/node_modules/@rx-angular/cdk/fesm2022/cdk-template.mjs"],"sourcesContent":["import { onStrategy, strategyHandling } from '@rx-angular/cdk/render-strategies';\nimport { of, BehaviorSubject, concat, EMPTY, merge, combineLatest, ReplaySubject } from 'rxjs';\nimport { ignoreElements, switchMap, map, withLatestFrom, catchError, tap, distinctUntilChanged } from 'rxjs/operators';\n\n/**\n * @internal\n * creates an embeddedViewRef\n *\n * @param viewContainerRef\n * @param templateRef\n * @param context\n * @param index\n * @return EmbeddedViewRef<C>\n */\nfunction createEmbeddedView(viewContainerRef, templateRef, context, index = 0) {\n    const view = viewContainerRef.createEmbeddedView(templateRef, context, index);\n    view.detectChanges();\n    return view;\n}\n/**\n * @internal\n *\n * A factory function returning an object to handle `TemplateRef`'s.\n * You can add and get a `TemplateRef`.\n *\n */\nfunction templateHandling(viewContainerRef) {\n    const templateCache = new Map();\n    const get$ = (name) => {\n        return templateCache.get(name) || of(undefined);\n    };\n    const get = (name) => {\n        let ref;\n        const templatRef$ = get$(name);\n        if (templatRef$) {\n            const sub = templatRef$.subscribe((r) => (ref = r));\n            sub.unsubscribe();\n        }\n        return ref;\n    };\n    return {\n        add(name, templateRef) {\n            assertTemplate(name, templateRef);\n            if (!templateCache.has(name)) {\n                templateCache.set(name, new BehaviorSubject(templateRef));\n            }\n            else {\n                templateCache.get(name).next(templateRef);\n            }\n        },\n        get$,\n        get,\n        createEmbeddedView: (name, context) => createEmbeddedView(viewContainerRef, get(name), context),\n    };\n    //\n    function assertTemplate(property, templateRef) {\n        const isTemplateRefOrNull = !!(!templateRef || templateRef.createEmbeddedView);\n        if (!isTemplateRefOrNull) {\n            throw new Error(`${property} must be a TemplateRef, but received ${typeof templateRef}`);\n        }\n        return isTemplateRefOrNull;\n    }\n}\n/**\n * @internal\n *\n * A side effect operator similar to `tap` but with a static internal logic.\n * It calls detect changes on the 'VirtualParent' and the injectingViewCdRef.\n *\n * @param injectingViewCdRef\n * @param strategy\n * @param notifyNeeded\n * @param ngZone\n */\nfunction notifyAllParentsIfNeeded(injectingViewCdRef, strategy, notifyNeeded, ngZone) {\n    return (o$) => o$.pipe(switchMap((v) => {\n        const notifyParent = notifyNeeded();\n        if (!notifyParent) {\n            return of(v);\n        }\n        return concat(of(v), onStrategy(injectingViewCdRef, strategy, (_v, work, options) => {\n            /*console.log(\n             'notifyAllParentsIfNeeded injectingView',\n             (injectingViewCdRef as any).context\n             );*/\n            work(injectingViewCdRef, options.scope);\n        }, {\n            scope: injectingViewCdRef.context || injectingViewCdRef,\n            ngZone,\n        }).pipe(ignoreElements()));\n    }));\n}\n\nvar RxBaseTemplateNames;\n(function (RxBaseTemplateNames) {\n    RxBaseTemplateNames[\"error\"] = \"errorTpl\";\n    RxBaseTemplateNames[\"complete\"] = \"completeTpl\";\n    RxBaseTemplateNames[\"suspense\"] = \"suspenseTpl\";\n})(RxBaseTemplateNames || (RxBaseTemplateNames = {}));\n\n/** @internal **/\nfunction isRxRenderError(e) {\n    return (e != null && Array.isArray(e) && e.length === 2 && e[0] instanceof Error);\n}\n/** @internal **/\nfunction createErrorHandler(_handler) {\n    const _handleError = _handler\n        ? (e) => _handler.handleError(e)\n        : console.error;\n    return {\n        handleError: (error) => {\n            if (isRxRenderError(error)) {\n                _handleError(error[0]);\n                console.error('additionalErrorContext', error[1]);\n            }\n            else {\n                _handleError(error);\n            }\n        },\n    };\n}\n/** @internal **/\nfunction toRenderError(e, context) {\n    return [e, context];\n}\n\n/**\n * @internal\n *\n * A factory function that returns a map of projections to turn a notification of a Observable (next, error, complete)\n *\n * @param customNextContext - projection function to provide custom properties as well as override existing\n */\nfunction notificationKindToViewContext(customNextContext) {\n    // @TODO rethink overrides\n    return {\n        suspense: (notification) => {\n            const $implicit = notification.value;\n            return {\n                $implicit,\n                suspense: true,\n                error: false,\n                complete: false,\n                ...customNextContext($implicit),\n            };\n        },\n        next: (notification) => {\n            const $implicit = notification.value;\n            return {\n                $implicit,\n                suspense: false,\n                error: false,\n                complete: false,\n                ...customNextContext($implicit),\n            };\n        },\n        error: (notification) => {\n            const $implicit = notification.value;\n            return {\n                $implicit,\n                complete: false,\n                error: notification.error || true,\n                suspense: false,\n                ...customNextContext($implicit),\n            };\n        },\n        complete: (notification) => {\n            const $implicit = notification.value;\n            return {\n                $implicit,\n                error: false,\n                complete: true,\n                suspense: false,\n                ...customNextContext($implicit),\n            };\n        },\n    };\n}\nfunction createTemplateManager(config) {\n    const { renderSettings, notificationToTemplateName, templateSettings } = config;\n    const { defaultStrategyName, strategies, cdRef: injectingViewCdRef, patchZone, parent, } = renderSettings;\n    const errorHandler = createErrorHandler(renderSettings.errorHandler);\n    const ngZone = patchZone ? patchZone : undefined;\n    let activeTemplate;\n    const strategyHandling$ = strategyHandling(defaultStrategyName, strategies);\n    const templates = templateHandling(templateSettings.viewContainerRef);\n    const viewContainerRef = templateSettings.viewContainerRef;\n    const triggerHandling = config.templateTrigger$ || EMPTY;\n    const getContext = notificationKindToViewContext(templateSettings.customContext || (() => ({})));\n    return {\n        addTemplateRef: (name, templateRef) => {\n            templates.add(name, templateRef);\n        },\n        nextStrategy: strategyHandling$.next,\n        render(values$) {\n            let trg;\n            let notification = {\n                value: undefined,\n                complete: false,\n                error: false,\n                kind: \"suspense\" /* RxNotificationKind.Suspense */,\n                hasValue: false,\n            };\n            return merge(values$.pipe(tap((n) => (notification = n))), triggerHandling.pipe(tap((trigger) => (trg = trigger)))).pipe(switchMap(() => {\n                const contextKind = trg || notification.kind;\n                trg = undefined;\n                const value = notification.value;\n                const templateName = notificationToTemplateName[contextKind](value, templates);\n                return templates.get$(templateName).pipe(map((template) => ({\n                    template,\n                    templateName,\n                    notification,\n                    contextKind,\n                })));\n            }), withLatestFrom(strategyHandling$.strategy$), \n            // Cancel old renders\n            switchMap(([{ template, templateName, notification, contextKind }, strategy,]) => {\n                const isNewTemplate = activeTemplate !== template || !template;\n                const notifyParent = isNewTemplate && parent;\n                return onStrategy(notification.value, strategy, (v, work, options) => {\n                    const context = getContext[contextKind](notification);\n                    if (isNewTemplate) {\n                        // template has changed (undefined => next; suspense => next; ...)\n                        // handle remove & insert\n                        // remove current view if there is any\n                        if (viewContainerRef.length > 0) {\n                            // patch removal if needed\n                            viewContainerRef.clear();\n                        }\n                        // create new view if any\n                        if (template) {\n                            // createEmbeddedView is already patched, no need for workFactory\n                            templates.createEmbeddedView(templateName, context);\n                        }\n                    }\n                    else if (template) {\n                        // template didn't change, update it\n                        // handle update\n                        const view = viewContainerRef.get(0);\n                        Object.keys(context).forEach((k) => {\n                            view.context[k] = context[k];\n                        });\n                        // update view context, patch if needed\n                        work(view, options.scope, notification);\n                    }\n                    activeTemplate = template;\n                }, { ngZone }\n                // we don't need to specify any scope here. The template manager is the only one\n                // who will call `viewRef#detectChanges` on any of the templates it manages.\n                // whenever a new value comes in, any pre-scheduled work of this taskManager will\n                // be nooped before a new work will be scheduled. This happens because of the implementation\n                // of `StrategyCredential#behavior`\n                ).pipe(notifyAllParentsIfNeeded(injectingViewCdRef, strategy, () => notifyParent, ngZone), catchError((e) => {\n                    errorHandler.handleError(e);\n                    return of(e);\n                }));\n            }));\n        },\n    };\n}\n\n/**\n * @internal\n *\n * Factory that returns a `ListTemplateManager` for the passed params.\n *\n * @param templateSettings\n */\nfunction getTemplateHandler(templateSettings) {\n    const { viewContainerRef, initialTemplateRef, createViewContext, updateViewContext, } = templateSettings;\n    return {\n        updateUnchangedContext,\n        insertView,\n        moveView,\n        removeView,\n        getListChanges,\n        updateView,\n    };\n    // =====\n    function updateUnchangedContext(item, index, count) {\n        const view = viewContainerRef.get(index);\n        updateViewContext(item, view, {\n            count,\n            index,\n        });\n        view.detectChanges();\n    }\n    function moveView(oldIndex, item, index, count) {\n        const oldView = viewContainerRef.get(oldIndex);\n        const view = viewContainerRef.move(oldView, index);\n        updateViewContext(item, view, {\n            count,\n            index,\n        });\n        view.detectChanges();\n    }\n    function updateView(item, index, count) {\n        const view = viewContainerRef.get(index);\n        updateViewContext(item, view, {\n            count,\n            index,\n        });\n        view.detectChanges();\n    }\n    function removeView(index) {\n        return viewContainerRef.remove(index);\n    }\n    function insertView(item, index, count) {\n        createEmbeddedView(viewContainerRef, initialTemplateRef, createViewContext(item, {\n            count,\n            index,\n        }), index);\n    }\n}\n/**\n * @internal\n *\n * @param changes\n * @param items\n */\nfunction getListChanges(changes, items) {\n    const changedIdxs = new Set();\n    const changesArr = [];\n    let notifyParent = false;\n    changes.forEachOperation((record, adjustedPreviousIndex, currentIndex) => {\n        const item = record.item;\n        if (record.previousIndex == null) {\n            // insert\n            changesArr.push(getInsertChange(item, currentIndex === null ? undefined : currentIndex));\n            changedIdxs.add(item);\n            notifyParent = true;\n        }\n        else if (currentIndex == null) {\n            // remove\n            changesArr.push(getRemoveChange(item, adjustedPreviousIndex === null ? undefined : adjustedPreviousIndex));\n            notifyParent = true;\n        }\n        else if (adjustedPreviousIndex !== null) {\n            // move\n            changesArr.push(getMoveChange(item, currentIndex, adjustedPreviousIndex));\n            changedIdxs.add(item);\n            notifyParent = true;\n        }\n    });\n    changes.forEachIdentityChange((record) => {\n        const item = record.item;\n        if (!changedIdxs.has(item)) {\n            changesArr.push(getUpdateChange(item, record.currentIndex));\n            changedIdxs.add(item);\n        }\n    });\n    items.forEach((item, index) => {\n        if (!changedIdxs.has(item)) {\n            changesArr.push(getUnchangedChange(item, index));\n        }\n    });\n    return [changesArr, notifyParent];\n    // ==========\n    function getMoveChange(item, currentIndex, adjustedPreviousIndex) {\n        return [\n            2 /* RxListTemplateChangeType.move */,\n            [item, currentIndex, adjustedPreviousIndex],\n        ];\n    }\n    function getUpdateChange(item, currentIndex) {\n        return [3 /* RxListTemplateChangeType.update */, [item, currentIndex]];\n    }\n    function getUnchangedChange(item, index) {\n        return [4 /* RxListTemplateChangeType.context */, [item, index]];\n    }\n    function getInsertChange(item, currentIndex) {\n        return [\n            0 /* RxListTemplateChangeType.insert */,\n            [item, currentIndex === null ? undefined : currentIndex],\n        ];\n    }\n    function getRemoveChange(item, adjustedPreviousIndex) {\n        return [\n            1 /* RxListTemplateChangeType.remove */,\n            [\n                item,\n                adjustedPreviousIndex === null ? undefined : adjustedPreviousIndex,\n            ],\n        ];\n    }\n}\n\nfunction createListTemplateManager(config) {\n    const { templateSettings, renderSettings, trackBy, iterableDiffers } = config;\n    const { defaultStrategyName, strategies, cdRef: injectingViewCdRef, patchZone, parent, } = renderSettings;\n    const errorHandler = createErrorHandler(renderSettings.errorHandler);\n    const ngZone = patchZone ? patchZone : undefined;\n    const strategyHandling$ = strategyHandling(defaultStrategyName, strategies);\n    let _differ;\n    function getDiffer(values) {\n        if (_differ) {\n            return _differ;\n        }\n        return values\n            ? (_differ = iterableDiffers.find(values).create(trackBy))\n            : null;\n    }\n    //               type,  context\n    /* TODO (regarding createView): this is currently not in use. for the list-manager this would mean to provide\n     functions for not only create. developers than should have to provide create, move, remove,... the whole thing.\n     i don't know if this is the right decision for a first RC */\n    const listViewHandler = getTemplateHandler({\n        ...templateSettings,\n        initialTemplateRef: templateSettings.templateRef,\n    });\n    const viewContainerRef = templateSettings.viewContainerRef;\n    let notifyParent = false;\n    let changesArr;\n    let partiallyFinished = false;\n    return {\n        nextStrategy(nextConfig) {\n            strategyHandling$.next(nextConfig);\n        },\n        render(values$) {\n            return values$.pipe(render());\n        },\n    };\n    function handleError() {\n        return (o$) => o$.pipe(catchError((err) => {\n            partiallyFinished = false;\n            errorHandler.handleError(err);\n            return of(null);\n        }));\n    }\n    function render() {\n        return (o$) => combineLatest([\n            o$,\n            strategyHandling$.strategy$.pipe(distinctUntilChanged()),\n        ]).pipe(map(([iterable, strategy]) => {\n            const differ = getDiffer(iterable);\n            let changes;\n            if (differ) {\n                if (partiallyFinished) {\n                    const currentIterable = [];\n                    for (let i = 0, ilen = viewContainerRef.length; i < ilen; i++) {\n                        const viewRef = viewContainerRef.get(i);\n                        currentIterable[i] = viewRef.context.$implicit;\n                    }\n                    differ.diff(currentIterable);\n                }\n                changes = differ.diff(iterable);\n            }\n            return {\n                changes,\n                iterable,\n                strategy,\n            };\n        }), \n        // Cancel old renders\n        switchMap(({ changes, iterable, strategy }) => {\n            if (!changes) {\n                return of([]);\n            }\n            const values = iterable || [];\n            // TODO: we might want to treat other iterables in a more performant way than Array.from()\n            const items = Array.isArray(values) ? values : Array.from(iterable);\n            const listChanges = listViewHandler.getListChanges(changes, items);\n            changesArr = listChanges[0];\n            const insertedOrRemoved = listChanges[1];\n            const applyChanges$ = getObservablesFromChangesArray(changesArr, strategy, items.length);\n            partiallyFinished = true;\n            notifyParent = insertedOrRemoved && parent;\n            return combineLatest(applyChanges$.length > 0 ? applyChanges$ : [of(null)]).pipe(tap(() => (partiallyFinished = false)), notifyAllParentsIfNeeded(injectingViewCdRef, strategy, () => notifyParent, ngZone), handleError(), map(() => iterable));\n        }), handleError());\n    }\n    /**\n     * @internal\n     *\n     * returns an array of streams which process all of the view updates needed to reflect the latest diff to the\n     * viewContainer.\n     * I\n     *\n     * @param changes\n     * @param strategy\n     * @param count\n     */\n    function getObservablesFromChangesArray(changes, strategy, count) {\n        return changes.length > 0\n            ? changes.map((change) => {\n                const payload = change[1];\n                return onStrategy(change[0], strategy, (type) => {\n                    switch (type) {\n                        case 0 /* RxListTemplateChangeType.insert */:\n                            listViewHandler.insertView(payload[0], payload[1], count);\n                            break;\n                        case 2 /* RxListTemplateChangeType.move */:\n                            listViewHandler.moveView(payload[2], payload[0], payload[1], count);\n                            break;\n                        case 1 /* RxListTemplateChangeType.remove */:\n                            listViewHandler.removeView(payload[1]);\n                            break;\n                        case 3 /* RxListTemplateChangeType.update */:\n                            listViewHandler.updateView(payload[0], payload[1], count);\n                            break;\n                        case 4 /* RxListTemplateChangeType.context */:\n                            listViewHandler.updateUnchangedContext(payload[0], payload[1], count);\n                            break;\n                    }\n                }, { ngZone });\n            })\n            : [of(null)];\n    }\n}\n\nconst computeFirst = ({ count, index }) => index === 0;\nconst computeLast = ({ count, index }) => index === count - 1;\nconst computeEven = ({ count, index }) => index % 2 === 0;\nclass RxDefaultListViewContext {\n    _item = new ReplaySubject(1);\n    item$ = this._item.asObservable();\n    _$implicit;\n    _$complete;\n    _$error;\n    _$suspense;\n    _context$ = new BehaviorSubject({\n        index: -1,\n        count: -1,\n    });\n    set $implicit($implicit) {\n        this._$implicit = $implicit;\n        this._item.next($implicit);\n    }\n    get $implicit() {\n        return this._$implicit;\n    }\n    get $complete() {\n        return this._$complete;\n    }\n    get $error() {\n        return this._$error;\n    }\n    get $suspense() {\n        return this._$suspense;\n    }\n    get index() {\n        return this._context$.getValue().index;\n    }\n    get count() {\n        return this._context$.getValue().count;\n    }\n    get first() {\n        return computeFirst(this._context$.getValue());\n    }\n    get last() {\n        return computeLast(this._context$.getValue());\n    }\n    get even() {\n        return computeEven(this._context$.getValue());\n    }\n    get odd() {\n        return !this.even;\n    }\n    get index$() {\n        return this._context$.pipe(map((c) => c.index), distinctUntilChanged());\n    }\n    get count$() {\n        return this._context$.pipe(map((s) => s.count), distinctUntilChanged());\n    }\n    get first$() {\n        return this._context$.pipe(map(computeFirst), distinctUntilChanged());\n    }\n    get last$() {\n        return this._context$.pipe(map(computeLast), distinctUntilChanged());\n    }\n    get even$() {\n        return this._context$.pipe(map(computeEven), distinctUntilChanged());\n    }\n    get odd$() {\n        return this.even$.pipe(map((even) => !even));\n    }\n    constructor(item, customProps) {\n        this.$implicit = item;\n        if (customProps) {\n            this.updateContext(customProps);\n        }\n    }\n    updateContext(newProps) {\n        this._context$.next({\n            ...this._context$.getValue(),\n            ...newProps,\n        });\n    }\n    select = (props) => {\n        return this.item$.pipe(map((r) => props.reduce((acc, key) => acc?.[key], r)));\n    };\n}\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { RxBaseTemplateNames, RxDefaultListViewContext, createListTemplateManager, createTemplateManager, templateHandling };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}